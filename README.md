# CPlusPlus 算法实现

> 使用CMake和MinGW进行构建，实现内容包括STL中的数据结构和《算法 第四版》中的算法，实现的方式参考STL库，采取数据结构与算法分离的形式，
> 主要使用C++的泛型方法进行编程，同时将实现内容放置于命名空间alg中，README文件会对实现等内容进行详细介绍。

## 调用方法

```shell
git clone 
```

## 数据结构实现

基本方法：从抽象数据类型（ADT）出发，设计模型的接口，再通过连续或链接的形式实现数据结构，并在此基础上实现基于此的算法。

### 向量 vector

### 列表 list

## 算法实现

### 排序算法

<math>\frac{a}{b}</math><math>

| 排序算法 | 平均时间复杂度     | 最好情况 | 最坏情况 | 平均空间复杂度 | 排序方法 | 稳定性 |
|------|-------------|------|------|---------|------|-----|
| 选择排序 | O(n^2)      |      |      |         |      |     |
| 插入排序 | O(n^2)      |      |      |         |      |     |
| 冒泡排序 | O(n^2)      |      |      |         |      |     |
| 希尔排序 | O(nlog(n))  |      |      |         |      |     |
| 归并排序 | O(nlog(n))  |      |      |         |      |     |
| 快速排序 | O(nlog(n))  |      |      |         |      |     |

## debug

* 在处理merge时，采用在公有函数中新建数组的方法实现不占用过多内存空间，在处理最后的原地归并时，课本上使用的代码先判断`i`和`j`是否越界， 再判断选择
  对哪边边进行归并，但是如果直接根据warning显示的存在重复的语句，即存在两个`a[k] = aux[i++]`，以及`a[k] = aux[j++]`，将越界判断和选择放在一起
  判断，会导致进行归并时出错，因为可能出现访问数组时越界的现象。

```c++
if (i > mid) a[k] = aux[j++];    // 正确
else if (j > hi) a[k] = aux[i++];
else if (less(aux[i], aux[j])) a[k] = aux[i++];
else a[k] = aux[j++];
```

```c++
if (i > mid || less(aux[j], aux[i])) a[k] = aux[j++];    // 错误
else a[k] = a[i++];
```

* 在编写代码时一定要注意每一个细节，特别是相近的变量之间的区别，否则会导致debug特别困难。

```c++
_item = new Item[_size];    // 应该为_capacity     
```

## 实现记录

2022/8/10 vector实现：构造，基本功能（增删改查）    
2022/8/13 list实现：构造，基本功能    
2022/8/15 架构完善，目前只是重新包装一下标准库    